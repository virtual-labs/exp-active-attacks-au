<!DOCTYPE html>
<html lang="en">
<head>
    <title>Network Graph</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        .links line {
            stroke-width: 3px;
        }

        .nodes circle {
            stroke: #fff;
            stroke-width: 3px;
        }

        html, body {
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
            font-family: Avenir, Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #F9FAFE;
            overflow: hidden;
        }

        * {
            box-sizing: border-box;
        }

        .nodes text {
            font-size: 12px;
        }

        #chart {
            flex: 6;
            background-color: white;
            height: 100vh; /* Fill viewport height */
            min-height: 400px;
            width: 100%;
            min-width: 300px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .flex-box {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: stretch;
            width: 100vw;
            height: 100vh;
            min-height: 600px;
            background-color: #f5f5f5;
            overflow: hidden; /* Remove x scroll, ensure no scrollbars */
        }

        .control-panel {
            padding: 20px;
            flex: 0 0 340px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: stretch;
            width: 340px;
            min-width: 320px;
            max-width: 400px;
            height: 100%; /* Fill viewport height */
            margin: auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #e0e0e0;
            overflow-y: auto;
        }

        #logs {
            height: 100vh; /* Fill viewport height */
            flex: 0 0 340px;
            min-width: 320px;
            max-width: 400px;
            align-self: stretch;
            background-color: #121212;
            color: white;
            font-family: "Lucida Console", Monaco, monospace;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: start;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #222;
            overflow-y: auto;
        }

        .legend-box {
            background: #fafcff;
            border: 1px solid #d0e0e0;
            border-radius: 6px;
            padding: 10px 12px;
            margin-top: 18px;
            margin-bottom: 10px;
        }

        .legend-row {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        .legend-row:last-child {
            margin-bottom: 0;
        }

        .circle {
            margin-left: 0;
            margin-right: 8px;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            display: inline-block;
            vertical-align: middle;
        }
        .circle.syn {
            background-color: #0d1a6b;
        }
        .circle.synack {
            background-color: #f44336;
        }
        .circle.ack {
            background-color: #4caf50;
        }

        .expected-box {
            background: #eafaf1;
            border-left: 4px solid #4caf50;
            border-radius: 4px;
            padding: 10px 12px;
            margin: 12px 0 18px 0;
            font-size: 15px;
        }
        .expected-title {
            font-weight: bold;
            color: #222;
            font-size: 16px;
            margin-bottom: 2px;
        }

        h2 {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 18px;
            color: #222;
        }
        .section-title {
            font-size: 18px;
            font-weight: bold;
            color: #111;
            margin-bottom: 8px;
            margin-top: 10px;
            letter-spacing: 0.5px;
        }
        .section-content {
            color: #444;
            font-size: 15px;
            margin-bottom: 18px;
            margin-left: 2px;
            margin-top: 2px;
            line-height: 1.6;
        }

        label {
            font-size: 15px;
            margin-top: 10px;
            margin-bottom: 2px;
            color: #222;
        }

        input[type=number] {
            width: 100%;
            padding: 10px 14px;
            margin: 8px 0 12px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 15px;
        }

        button {
            width: 100%;
            background-color: #4CAF50;
            color: white;
            padding: 14px 0;
            margin: 8px 0 18px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
        }

        .flex {
            margin-top: 40px;
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
            height: fit-content;
        }

        h4 {
            padding: 0;
            margin: 0 0 10px;
            color: #919191;
            font-weight: 400;
            
        }

        #logs {
            height: 100vh; /* Fill viewport height */
            flex: 0 0 340px;
            min-width: 320px;
            max-width: 400px;
            align-self: stretch;
            background-color: #121212;
            color: white;
            font-family: "Lucida Console", Monaco, monospace;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: start;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border: 1px solid #222;
            overflow-y: auto;
        }

        h3 {
            padding: 0;
            margin: 0 0 10px;
            color: white;
            font-weight: 400;
            border-bottom: 1px solid #919191;
        }

        #log-list {
            padding: 0;
            margin: 0;
            width: 100%;
            height: calc(100vh - 60px); /* Fill available height minus header */
            overflow-y: auto;
            overflow-x: hidden;
            color: white;
            background-color: #121212;
        }

        
        li {
            margin-top: 10px;
        }

        .attack-info {
            margin-top: 10px;
            font-weight: 500;
        }

    </style>
</head>
<body>
<div class="flex-box">
    <div class="control-panel">
        <h2>
            TCP SYN Flood Attack Simulation using network graph
        </h2>
        <div>
            <div class="section-title">Aim</div>
            <div class="section-content">
                To visually demonstrate the TCP three-way handshake protocol and how SYN flood attacks exploit it to overwhelm a server.
            </div>
            <div class="section-title">Procedure</div>
            <div class="section-content">
                Choose the number of clients and servers required and click on "Generate Graph" to generate the graph. Click on a client and then a server to establish an attack from the client to the server.
            </div>
            <div class="expected-box">
                <div class="expected-title">Expected Outcome:</div>
                Observe packets in order (SYN → SYN-ACK → ACK) by their legend colors. Logs will display each protocol step. When a SYN flood occurs, the server will be overwhelmed and a message indicating the server is down will be displayed in the log section.
            </div>
            <label>Number of Servers</label>
            <input type="number" id="countServer" name="count" min="1" max="50" value="1">
            <label>Number of Clients</label>
            <input type="number" id="countClient" name="count" min="1" max="50" value="1">

            <button onclick="init()" id="button">Generate Graph</button>

            <div class="legend-box">
                <div class="legend-row"><span class="circle syn"></span> <span>SYN packet</span></div>
                <div class="legend-row"><span class="circle synack"></span> <span>SYN-ACK packet</span></div>
                <div class="legend-row"><span class="circle ack"></span> <span>ACK packet</span></div>
            </div>

            <span class="attack-info">Attacking client: </span>
            <span id="client-id"></span>
            <br>
            <span class="attack-info">Target server: </span>
            <span id="server-id"></span>
        </div>
    </div>
    <div id="chart"></div>
    <div id="logs">
        <h3>
            Logs
        </h3>
        <ul id="log-list">

        </ul>
    </div>
</div>


<script>
    let nodes = [];

    let links = [];

    let serverCountCreated = 0

    let clientCountCreated = 0

    let isSimulationInitialized = false

    function addClientWrapper(count) {
        for (let i = 0; i < count; i++) {
            addClient()
            console.log("added client")
        }
    }

    function addServerWrapper(count) {
        for (let i = 0; i < count; i++) {
            addServer()
            console.log("added server")
        }
    }

    function addServer() {
        nodes.push({
            id: "server" + (serverCountCreated + 1),
            type: "server",
            icon: "server.svg",
            isClicked: false,
            isServerDown: false
        })
        links.push({source: "server" + (serverCountCreated + 1), target: "gateway", color: "#8a8ac2"})
        serverCountCreated++
    }

    function addClient() {
        nodes.push({
            id: "client" + (clientCountCreated + 1),
            type: "client",
            icon: "workstation.svg",
            isClicked: false,
            isLineOccupied: false
        })
        links.push({source: "client" + (clientCountCreated + 1), target: "gateway", color: "#8a8ac2"})
        clientCountCreated++
    }

    function init() {
        // Always allow graph regeneration
        // Clear previous graph and state
        d3.select("#chart").selectAll("svg").remove();
        nodes = [];
        links = [];
        serverCountCreated = 0;
        clientCountCreated = 0;
        isSimulationInitialized = false;
        document.getElementById("client-id").innerHTML = "";
        document.getElementById("server-id").innerHTML = "";
        let logList = document.getElementById("log-list");
        logList.innerHTML = "";

        let serverCount = document.getElementById("countServer").value
        serverCount = parseInt(serverCount)

        let attackingClient = null
        let targetServer = null

        if (isNaN(serverCount)) {
            logList.innerHTML += "<li>Invalid input</li>"
            logList.scrollTo(0, logList.scrollHeight * 100)
            return
        }

        if (serverCount < 1 || serverCount > 50) {
            logList.innerHTML += "<li>Please enter number of servers greater than 0 and less than 50</li>"
            logList.scrollTo(0, logList.scrollHeight * 100)
            return
        }

        let clientCount = document.getElementById("countClient").value
        clientCount = parseInt(clientCount)

        if (isNaN(clientCount)) {
            logList.innerHTML += "<li>Invalid input</li>"
            logList.scrollTo(0, logList.scrollHeight * 100)
            return
        }

        if (clientCount < 1 || clientCount > 50) {
            logList.innerHTML += "<li>Please enter number of clients greater than 0 and less than 50</li>"
            logList.scrollTo(0, logList.scrollHeight * 100)
            return
        }

        addClientWrapper(parseInt(clientCount))
        addServerWrapper(parseInt(serverCount))

        isSimulationInitialized = true
        logList.innerHTML += "<li>Graph has been generated</li>"
        logList.scrollTo(0, logList.scrollHeight * 100)
        document.getElementById("button").disabled = false;

        // Get chart area size for centering
        let chartDiv = document.getElementById("chart");
        let width = chartDiv.offsetWidth || 1000;
        let height = chartDiv.offsetHeight || 800;

        // Place gateway in the exact center
        nodes.push({id: "gateway", type: "gateway", icon: "router.svg", x: width/2, y: height/2});

        let svg = d3.select("#chart")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        let linkDistance = 200; // set the desired link distance
        let linkForce = d3.forceLink(links)
            .id(function (d) {
                return d.id;
            })
            .distance(linkDistance); // set the link distance value

        let simulation = d3.forceSimulation(nodes)
            .force("link", linkForce)
            .force("charge", d3.forceManyBody().strength(-1000))
            .force("center", d3.forceCenter(width/2, height/2))
            .force("y", d3.forceY().y(function (d) {
                if (d.type === "server") {
                    return height / 7;
                } else if (d.type === "client") {
                    return height * 0.75;
                } else {
                    return height / 2;
                }
            }))


        let link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(links)
            .enter()
            .append("line")
            .style("stroke", function (d) {
                return d.color;
            })
            .style("stroke-width", "2px");

        let node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("g")
            .data(nodes)
            .enter()
            .append("g")
            .call(drag(simulation));

        node.append("image")
            .attr("xlink:href", function (d) {
                if (d.type !== "gateway")
                    return d.icon;
            })
            .attr("x", -20)
            .attr("y", -20)
            .attr("width", 40)
            .attr("height", 40);

        //append circle to node of raduis 20 only for gateway
        node.append("circle")
            .attr("r", function (d) {
                if (d.type === "gateway") {
                    return 10
                } else {
                    return 0
                }
            })
            .attr("fill", function (d) {
                if (d.type === "gateway") {
                    return "#80c7b1";
                } else {
                    return "none";
                }
            })
            .attr("stroke", function (d) {
                if (d.type === "gateway") {
                    return "#8a8ac2";
                } else {
                    return "none";
                }
            })


        let text = svg.append("g")
            .attr("class", "texts")
            .selectAll("text")
            .data(nodes)
            .enter()
            .append("text")
            .text(function (d) {
                //if not gateway
                if (d.type !== "gateway") {
                    return d.id;
                }
            })
            .style("font-size", "12px")
            .attr("dx", 15)
            .attr("dy", 4);

        simulation.on("tick", function () {
            link
                .attr("x1", function (d) {
                    return d.source.x;
                })
                .attr("y1", function (d) {
                    return d.source.y;
                })
                .attr("x2", function (d) {
                    return d.target.x;
                })
                .attr("y2", function (d) {
                    return d.target.y;
                });

            node
                .attr("transform", function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });

            text
                .attr("x", function (d) {
                    return d.x;
                })
                .attr("y", function (d) {
                    return d.y;
                });

        });

        node.on("click", function (d) {
            let data = d.srcElement.__data__
            if (data.type === "client") {
                logList.innerHTML += '<li>Attack client <span style="color: red"> client ' + data.id.replace('client','') + '</span> has been chosen</li>';
                logList.scrollTo(0, logList.scrollHeight * 100)
                attackingClient = data.id;
                document.getElementById("client-id").innerHTML = data.id.replace('client','');
            } else if (data.type === "server") {
                logList.innerHTML += '<li>Target <span style="color: white">server </span><span style="color: red">server ' + data.id.replace('server','') + '</span> has been chosen</li>';
                logList.scrollTo(0, logList.scrollHeight * 100)
                targetServer = data.id;
                document.getElementById("server-id").innerHTML = data.id.replace('server','');
            }

            if (attackingClient !== null && targetServer !== null) {

                //set both client and server to be not clicked based on the id in attackingClient and targetServer
                let clientNode
                let serverNode
                for (let i = 0; i < nodes.length; i++) {
                    if (nodes[i].id === attackingClient) {
                        clientNode = nodes[i]
                    } else if (nodes[i].id === targetServer) {
                        serverNode = nodes[i]
                    }
                }

                console.log(clientNode, serverNode)

                if (!clientNode.isClicked && !serverNode.isClicked && !serverNode.isServerDown && !clientNode.isLineOccupied) {
                    clientNode.isClicked = true;
                    serverNode.isClicked = true;

                    // Always display attacking client and target server in control panel
                    document.getElementById("client-id").innerHTML = clientNode.id.replace('client','');
                    document.getElementById("server-id").innerHTML = serverNode.id.replace('server','');

                    attackingClient = null;
                    targetServer = null;
                    document.getElementById("client-id").innerHTML = "";
                    document.getElementById("server-id").innerHTML = "";

                    logList.innerHTML += '<li>Attacking <span style="color: red"> server ' + serverNode.id + '</span></li>';
                    logList.scrollTo(0, logList.scrollHeight * 100)

                    for (let i = 0; i < 6; i++) {
                        if (i === 0) {
                            twoOfThreeWayHandshake(clientNode, serverNode, i + 1);
                        } else {
                            setTimeout(function () {
                                twoOfThreeWayHandshake(clientNode, serverNode, i + 1);
                            }, 800 * i / 2);
                        }
                    }

                    setTimeout(function () {
                        logList.innerHTML += '<li><b>Server ' + serverNode.id.replace('server','') + ' is down.</b></li>';
                        logList.scrollTo(0, logList.scrollHeight * 100)
                        serverNode.isServerDown = true;
                        clientNode.isLineOccupied = true;
                        serverNode.isClicked = false;
                        clientNode.isClicked = false;
                        text.style("fill", function (d) {
                            if (d.isServerDown) {
                                return "red";
                            } else {
                                return "black";
                            }
                        })
                        link.style("stroke", function (d) {
                            if (d.source.isServerDown) {
                                return "red";
                            } else if (d.source.isLineOccupied) {
                                return "#fff200";
                            } else {
                                return d.color;
                            }
                        })
                    }, 800 * (15 / 2));


                } else if (serverNode.isServerDown === true) {
                    logList.innerHTML += '<li><b>Server ' + serverNode.id.replace('server','') + ' is already down, cannot send more packets as all ports are exhausted.</b></li>';
                    logList.scrollTo(0, logList.scrollHeight * 100)
                } else if (clientNode.isLineOccupied === true) {
                    logList.innerHTML += '<li>The ports used by <span style="color: red"> ' + clientNode.id + '</span> is already being used</li>';
                    logList.scrollTo(0, logList.scrollHeight * 100)
                } else {
                    logList.innerHTML += '<li>Server <span style="color: red"> server ' + serverNode.id + '</span> is already being attacked</li>';
                    logList.scrollTo(0, logList.scrollHeight * 100)
                }
            }
        })

        function twoOfThreeWayHandshake(clientData, serverData, iteration) {
            // Generate random SYN and ACK numbers for this handshake
            const synNum = Math.floor(Math.random() * 100000);
            const ackNum = synNum + 1;
            // 1. Client sends SYN (blue)
            movePacketWithLabel("client", "gateway", clientData.id, true, `SYN=${synNum}`, "syn");
            logList.innerHTML += `<li>Packet ${iteration} sent from <span style=\"color: #8a8ac2\">Client ${clientData.id.replace('client','')}</span> to <span style=\"color: #8a8ac2\">gateway</span> <b>[SYN=${synNum}]</b></li>`;
            logList.scrollTo(0, logList.scrollHeight * 100)
            setTimeout(function () {
                // 2. Server sends SYN-ACK (red)
                movePacketWithLabel("server", "gateway", serverData.id, false, `SYN=${ackNum} ACK=${synNum+1}`, "synack");
                setTimeout(function () {
                    logList.innerHTML += `<li>Packet reached <span style=\"color: #8a8ac2\">server ${serverData.id.replace('server','')}</span>, sending packet back to <span style=\"color: #8a8ac2\">client ${clientData.id.replace('client','')}</span> <b>[SYN=${ackNum} ACK=${synNum+1}]</b></li>`;
                    logList.scrollTo(0, logList.scrollHeight * 100)
                    // 3. Client sends ACK (green)
                    movePacketWithLabel("server", "gateway", serverData.id, true, `ACK=${ackNum+1}`, "ack");
                    setTimeout(function () {
                        movePacketWithLabel("client", "gateway", clientData.id, false, `ACK=${ackNum+1}`, "ack");
                        logList.innerHTML += `<li>Aborting three-way handshake number ${iteration} to keep port open with <span style=\"color: red\">server ${serverData.id.replace('server','')}</span></li>`;
                        logList.scrollTo(0, logList.scrollHeight * 100)
                    }, 1000)
                }, 1000);
            }, 1000);
        }

        // Move packet with color and label
        function movePacketWithLabel(sourceType, targetType, id, isSourceToTarget, label, colorClass) {
            let destination;
            let colorMap = { syn: "#2196f3", synack: "#f44336", ack: "#4caf50", data: "#ffb300" };
            let packetGroup = svg.append("g")
                .attr("class", "packet");
            let packet = packetGroup
                .selectAll("rect")
                .data(links.filter(function (d) {
                    return d.source.type === sourceType && d.target.type === targetType && d.source.id === id;
                }))
                .enter();
            let rect = packet.append("rect")
                .attr("width", 70)
                .attr("height", 44)
                .attr("rx", 12)
                .attr("ry", 12)
                .style("fill", colorMap[colorClass] || "#ff0000")
                .attr("x", function (d) {
                    if (isSourceToTarget) {
                        if (d.source.type === sourceType) {
                            destination = d.destination;
                            return d.source.x - 35;
                        }
                    } else {
                        if (d.target.type === targetType) {
                            destination = d.destination;
                            return d.target.x - 35;
                        }
                    }
                })
                .attr("y", function (d) {
                    if (isSourceToTarget) {
                        if (d.source.type === sourceType) {
                            return d.source.y - 22;
                        }
                    } else {
                        if (d.target.type === targetType) {
                            return d.target.y - 22;
                        }
                    }
                });

            // Split label into two lines: first line is protocol, second is number
            // For SYN: label = "SYN=12345" => line1: "SYN", line2: "12345" or "=12345"
            // For SYN/ACK: label = "SYN=12345 ACK=12346" => line1: "SYN/ACK", line2: "12345/12346" or "SYN=... ACK=..."
            // For ACK: label = "ACK=12346" => line1: "ACK", line2: "12346" or "=12346"
            let line1 = "";
            let line2 = "";
            if (colorClass === "syn") {
                line1 = "SYN";
                line2 = label.replace("SYN=", "");
            } else if (colorClass === "synack") {
                line1 = "SYN/ACK";
                // Try to extract numbers from label
                let synMatch = label.match(/SYN=(\d+)/);
                let ackMatch = label.match(/ACK=(\d+)/);
                if (synMatch && ackMatch) {
                    line2 = ackMatch[1]; // Only the number, no 'Port:'
                } else {
                    line2 = label;
                }
            } else if (colorClass === "ack") {
                line1 = "ACK";
                line2 = label.replace("ACK=", "");
            } else {
                line1 = label;
                line2 = "";
            }

            // Add first line (protocol)
            let text1 = packetGroup.selectAll(".packet-label1")
                .data(links.filter(function (d) {
                    return d.source.type === sourceType && d.target.type === targetType && d.source.id === id;
                }))
                .enter()
                .append("text")
                .attr("class", "packet-label1")
                .text(line1)
                .attr("font-size", "13px")
                .attr("font-weight", "bold")
                .attr("fill", "#111")
                .attr("text-anchor", "middle")
                .attr("x", function (d) {
                    if (isSourceToTarget) {
                        if (d.source.type === sourceType) {
                            return d.source.x;
                        }
                    } else {
                        if (d.target.type === targetType) {
                            return d.target.x;
                        }
                    }
                })
                .attr("y", function (d) {
                    if (isSourceToTarget) {
                        if (d.source.type === sourceType) {
                            return d.source.y - 4;
                        }
                    } else {
                        if (d.target.type === targetType) {
                            return d.target.y - 4;
                        }
                    }
                });
            // Add second line (number)
            let text2 = packetGroup.selectAll(".packet-label2")
                .data(links.filter(function (d) {
                    return d.source.type === sourceType && d.target.type === targetType && d.source.id === id;
                }))
                .enter()
                .append("text")
                .attr("class", "packet-label2")
                .text(line2)
                .attr("font-size", "13px")
                .attr("fill", "#111")
                .attr("text-anchor", "middle")
                .attr("x", function (d) {
                    if (isSourceToTarget) {
                        if (d.source.type === sourceType) {
                            return d.source.x;
                        }
                    } else {
                        if (d.target.type === targetType) {
                            return d.target.x;
                        }
                    }
                })
                .attr("y", function (d) {
                    if (isSourceToTarget) {
                        if (d.source.type === sourceType) {
                            return d.source.y + 14;
                        }
                    } else {
                        if (d.target.type === targetType) {
                            return d.target.y + 14;
                        }
                    }
                });

            // Animate both rect and text
            rect.transition()
                .duration(4000)
                .attr("x", function (d) {
                    if (isSourceToTarget) {
                        if (d.target.type === targetType) {
                            return d.target.x - 35;
                        }
                    } else {
                        if (d.source.type === sourceType) {
                            return d.source.x - 35;
                        }
                    }
                })
                .attr("y", function (d) {
                    if (isSourceToTarget) {
                        if (d.target.type === targetType) {
                            return d.target.y - 22;
                        }
                    } else {
                        if (d.source.type === sourceType) {
                            return d.source.y - 22;
                        }
                    }
                });
            text1.transition()
                .duration(4000)
                .attr("x", function (d) {
                    if (isSourceToTarget) {
                        if (d.target.type === targetType) {
                            return d.target.x;
                        }
                    } else {
                        if (d.source.type === sourceType) {
                            return d.source.x;
                        }
                    }
                })
                .attr("y", function (d) {
                    if (isSourceToTarget) {
                        if (d.target.type === targetType) {
                            return d.target.y - 4;
                        }
                    } else {
                        if (d.source.type === sourceType) {
                            return d.source.y - 4;
                        }
                    }
                });
            text2.transition()
                .duration(4000)
                .attr("x", function (d) {
                    if (isSourceToTarget) {
                        if (d.target.type === targetType) {
                            return d.target.x;
                        }
                    } else {
                        if (d.source.type === sourceType) {
                            return d.source.x;
                        }
                    }
                })
                .attr("y", function (d) {
                    if (isSourceToTarget) {
                        if (d.target.type === targetType) {
                            return d.target.y + 14;
                        }
                    } else {
                        if (d.source.type === sourceType) {
                            return d.source.y + 14;
                        }
                    }
                });
            setTimeout(function () {
                packetGroup.remove();
            }, 4000);
            return destination;
        }

        //animate the packet from client to gateway

        function drag(simulation) {
            function dragStarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                if (d.type === "gateway") return
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                if (d.type === "gateway") return
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragEnded(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                if (d.type === "gateway") return
                d.fx = null;
                d.fy = null;
            }

            return d3.drag()
                .on("start", dragStarted)
                .on("drag", dragged)
                .on("end", dragEnded);
        }
    }


</script>
</body>
</html>

